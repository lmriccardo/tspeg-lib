/**
 * Split the input value into two numbers. This is useful when splitting a single byte
 * into two 4-bits value, or a single 2-byte value into two bytes. That is given a
 * value X it will generate Y, Z such that Y is composed of N MSB while Z by the
 * remaining bits.
 * 
 * @param value The value that will be splitted
 * @param size  Where to split the value (in terms of bits)
 * 
 * @returns Y and Z values generated by splitting X
 */
export const SplitByte = (value: number, size: number = 4): [number, number] => 
{
  const value1 = value >> size;
  const value2 = value & ~(value1 << size);
  return [value1, value2];
}

/**
 * This generator function, yields each step at a time a single bit from a given value,
 * in order given as input: (MSB First) Left-to-rigth or (LSB first) Right-to-Left.
 * 
 * @param value The value from which extracts the bits
 * @param msb   The order flag. True indicates MSB first, false otherwise
 * @param dim   Force the total number of bits of the number to be dim
 * 
 * @returns A number generator
 */
export const BitGenerator = function* (value: number, msb: boolean=true, dim: number|null=null)
: Generator<number> {
  const nofBits = dim ?? Math.floor(Math.log2(value)) + 1; // Compute the total number of steps

  // If the msb flag is true, then we need to bits 
  // from left to right (MSB first)
  if (msb) {
    for (let i = nofBits - 1; i >= 0; i--) {
      yield (value >> i) & 1;
    }

    return;
  }

  // On the other hand, if msb flag is false, then 
  // we read from right to left (LSB first)
  for (let i = 0; i < nofBits; i++) {
    yield (value >> i) & 1;
  }
}

/**
 * This class represents a BitStream. It contains a buffer of bytes
 * and methods used to yield next bit in the input stream. 
 */
export class BitStream
{
  private readonly buffer : Buffer; // The acutal buffer object

  private position    : number = 0; // The current position in the buffer
  private currByte    : number = 0; // The current byte used to yeild the next bit
  private byteCounter : number = 0; // The byte counter for the next bit generation

  constructor(buffer: Buffer) {
    this.buffer = buffer;
  }

  /**
   * Construct a BitStream object starting from the input array of chars.
   * 
   * @param array The input array of uint8 (chars) elements
   * @returns a BitStream instance
   */
  static from(array: Uint8Array): BitStream {
    const buffer = Buffer.from(array);
    return new BitStream(buffer);
  }

  /**
   * Returns the total length of the buffer
   */
  public get length(): number { return this.buffer.length; }

  /**
   * Creates a subarray view of the existing buffer and returns a new
   * BitStream instance starting from that sub-buffer. It does not copy
   * the content of the buffer, instead it and its 'parent' share the same
   * memory location. The subarray is created starting from the current
   * position into the buffer. 
   * 
   * @param offset The starting offset (it adds to the current position in the buffer)
   * @param size   The number of bytes to taken from the original buffer
   * 
   * @throws  A new Error if boundary checks are unsatisfied.
   * @returns A new BitStream with a subview of the original array
   */
  subarray(offset?: number, size?: number) : BitStream {
    const start_pos = this.position + (offset ?? 0);
    const end_pos = size ? start_pos + size : this.length;
    
    // Boundary conditions check
    if (start_pos < 0 || end_pos > this.length || end_pos < start_pos) {
      throw new Error('[BitStream:subarray:InvalidBoundary] Invalid start end ending positions');
    }

    return new BitStream(this.buffer.subarray(start_pos, end_pos));
  }

  /**
   * Update the current position in the buffer by the input offset.
   * Hence, the resulting position will be position + offset.
   * 
   * @param offset The input offset
   */
  updatePosition(offset?: number) { this.position += offset ?? 0; }

  /**
   * This methods returns the next bit to be read. This method has the side
   * effect of increasing the position attribute if the current byte has
   * been fully read.
   * 
   * @returns The next bit
   */
  getNextBit(): number {
    if (this.byteCounter === 0) {
      // First we need to check for Out Of Bound position
      if (this.position + 1 >= this.buffer.length) throw new Error(
        '[BitStream:getNextBit:IndexOverflow] No more bytes to read.');

      this.position++; // Update the position
      this.byteCounter = 8; // Reset the byte counter to be 8
      this.currByte = this.buffer.readUInt8(this.position); // Read the next byte
    }

    const bit = this.currByte >> 7;
    this.byteCounter--;
    this.currByte = (this.currByte << 1) & 0xFF;
    return bit;
  }

  /**
   * Reads N bytes from the buffer starting from a given offset, 
   * or from the current position if offset is null or undefined.
   * Updates the position if the offset is not given.
   *  
   * @param n The number of bytes to be read.
   * @return The value corresponding to byte read
   */
  readBytes(n: number, offset?: number, le: boolean = false): number {
    const curr_position = offset ?? this.position;

    // Check if the current position plus the number of bytes to read
    // does not overflow the buffer dimension
    if (curr_position + n >= this.buffer.length) throw new Error(
      '[BitStream:readBytes:BufferOverflow] Impossible to read input bytes.');

    let curr_result = 0;
    const wrap = le ? n - 1 : 0;
    for (let idx = 0; idx < n; idx++) {
      const position = (le ? 1 : -1) * (wrap - idx); // Handle LE ordering
      curr_result = (curr_result << 8) | this.buffer.readUInt8(curr_position + position);

      if (curr_result > Number.MAX_SAFE_INTEGER) {
        throw new Error('[BitStream:readBytes:MaxIntegerReached] Maximum safe ' +
          'integer has been reached. Unable to continue.');
      }
    }

    this.position = offset ? this.position : this.position + n;
    return curr_result;
  }

  /**
   * Returns the next byte from the current position.
   * It does not update the position
   * @returns The next byte
   */
  getNextUInt8(): number {
    return this.readBytes(1, this.position);
  }

  /**
   * Returns the next short from the current position (Big-Endian)
   * It does not update the position
   * @returns The next short
   */
  getNextUInt16BE(): number {
    return this.buffer.readUInt16BE(this.position);
  }

  /**
   * Read a single byte from the input offset if given, else from the
   * current position. If the offset is not given, then position is updated.
   * 
   * @param offset The optional offset 
   * @returns The next 8-bit value
   */
  readUInt8(offset?: number): number {
    return this.readBytes(1, offset);
  }

  /**
   * Read a single short from the buffer starting at input offset, if given,
   * current position otherwise. If the offset is not given, then position is updated.
   * 
   * @param offset The optional offset 
   * @returns The next 16-bit value
   */
  readUInt16BE(offset?: number): number {
    return this.readBytes(2, offset);
  }
};